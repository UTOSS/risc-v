module uart_bus_master #(
    parameter int CLK_HZ = 50_000_000,
    parameter int BAUD   = 115200
)(
    input  wire        clk,
    input  wire        rst,

    // UART RX stream
    input  wire [7:0]  rx_data,
    input  wire        rx_valid,
    output wire        rx_ready,

    // UART TX stream
    output logic [7:0] tx_data,
    output logic       tx_valid,
    input  wire        tx_ready,

    // memory bus (single-cycle write strobe, 1-cycle read latency from your memory_map)
    output logic [31:0] bus_addr,
    output logic [31:0] bus_wdata,
    output logic [3:0]  bus_wstrb,
    input  wire [31:0]  bus_rdata,

    // control
    output logic        hold_core  // 1=hold core in reset and allow UART bus access
);

    assign rx_ready = 1'b1;

    localparam byte SOF      = 8'hA5;
    localparam byte RSOF     = 8'h5A;

    localparam byte CMD_WR32 = 8'h10;
    localparam byte CMD_RD32 = 8'h11;
    localparam byte CMD_RUN  = 8'h12;
    localparam byte CMD_HALT = 8'h13;

    localparam byte R_ACK    = 8'h90;
    localparam byte R_RD     = 8'h91;

    // default: after reset, hold core (方便你先用UART装程序)
    always_ff @(posedge clk) begin
        if (rst) hold_core <= 1'b1;
    end

    // parser
    typedef enum logic [3:0] {
        S_WAIT_SOF = 4'd0,
        S_CMD      = 4'd1,
        S_A0       = 4'd2,
        S_A1       = 4'd3,
        S_A2       = 4'd4,
        S_A3       = 4'd5,
        S_D0       = 4'd6,
        S_D1       = 4'd7,
        S_D2       = 4'd8,
        S_D3       = 4'd9,
        S_CHK      = 4'd10,
        S_DO_WR    = 4'd11,
        S_DO_RD_0  = 4'd12,
        S_DO_RD_1  = 4'd13,
        S_SEND     = 4'd14
    } st_t;

    st_t st;

    logic [7:0]  cmd;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [7:0]  chk_calc;
    logic [7:0]  chk_recv;

    logic [31:0] rdata_latched;
    logic [7:0]  status;

    // response sequencer
    logic [3:0]  send_idx;
    logic [7:0]  resp_chk;

    wire rx_fire = rx_valid & rx_ready;

    // bus defaults
    always_ff @(posedge clk) begin
        if (rst) begin
            bus_addr  <= 32'd0;
            bus_wdata <= 32'd0;
            bus_wstrb <= 4'b0000;

            tx_data   <= 8'd0;
            tx_valid  <= 1'b0;

            st        <= S_WAIT_SOF;
            cmd       <= 8'd0;
            addr      <= 32'd0;
            wdata     <= 32'd0;
            chk_calc  <= 8'd0;
            chk_recv  <= 8'd0;
            rdata_latched <= 32'd0;
            status    <= 8'd0;
            send_idx  <= 4'd0;
            resp_chk  <= 8'd0;
        end else begin
            // default: no bus write unless pulsed
            bus_wstrb <= 4'b0000;

            // default: drop tx_valid after handshake
            if (tx_valid && tx_ready) tx_valid <= 1'b0;

            case (st)
                S_WAIT_SOF: begin
                    if (rx_fire && rx_data == SOF) begin
                        st       <= S_CMD;
                    end
                end

                S_CMD: if (rx_fire) begin
                    cmd      <= rx_data;
                    chk_calc <= rx_data; // start XOR from CMD
                    addr     <= 32'd0;
                    wdata    <= 32'd0;

                    if (rx_data == CMD_RUN || rx_data == CMD_HALT) begin
                        st <= S_CHK;
                    end else begin
                        st <= S_A0;
                    end
                end

                S_A0: if (rx_fire) begin addr[7:0]   <= rx_data; chk_calc <= chk_calc ^ rx_data; st <= S_A1; end
                S_A1: if (rx_fire) begin addr[15:8]  <= rx_data; chk_calc <= chk_calc ^ rx_data; st <= S_A2; end
                S_A2: if (rx_fire) begin addr[23:16] <= rx_data; chk_calc <= chk_calc ^ rx_data; st <= S_A3; end
                S_A3: if (rx_fire) begin
                    addr[31:24] <= rx_data;
                    chk_calc    <= chk_calc ^ rx_data;
                    if (cmd == CMD_WR32) st <= S_D0;
                    else                 st <= S_CHK;  // RD32 -> checksum next
                end

                S_D0: if (rx_fir
